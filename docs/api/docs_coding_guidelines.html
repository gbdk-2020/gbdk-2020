<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="cache-control" content="max-age=86400"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GBDK 2020 Docs: Coding Guidelines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GBDK 2020 Docs
   </div>
   <div id="projectbrief">API Documentation for GBDK 2020</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('docs_coding_guidelines.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Coding Guidelines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md42"></a>
Learning C / C fundamentals</h1>
<p>Writing games and other programs with GBDK will be much easier with a basic understanding of the C language. In particular, understanding how to use C on "Embedded Platforms" (small computing systems, such as the Game Boy) can help you write better code (smaller, faster, less error prone) and avoid common pitfals.</p>
<p><a class="anchor" id="docs_c_tutorials"></a></p>
<h2><a class="anchor" id="autotoc_md43"></a>
General C tutorials</h2>
<ul>
<li><a href="https://www.learn-c.org/">https://www.learn-c.org/</a></li>
<li><a href="https://www.tutorialspoint.com/cprogramming/index.htm">https://www.tutorialspoint.com/cprogramming/index.htm</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md44"></a>
Embedded C introductions</h2>
<ul>
<li><a href="http://dsp-book.narod.ru/CPES.pdf">http://dsp-book.narod.ru/CPES.pdf</a></li>
<li><a href="https://www.phaedsys.com/principals/bytecraft/bytecraftdata/bcfirststeps.pdf">https://www.phaedsys.com/principals/bytecraft/bytecraftdata/bcfirststeps.pdf</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md45"></a>
Game Boy games in C</h2>
<ul>
<li><a href="https://gbdev.io/list.html#c">https://gbdev.io/list.html#c</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md46"></a>
Understanding the hardware</h1>
<p>In addition to understanding the C language it's important to learn how the Game Boy hardware works. What it is capable of doing, what it isn't able to do, and what resources are available to work with. A good way to do this is by reading the <a class="el" href="docs_links_and_tools.html#Pandocs">Pandocs</a> and checking out the <a class="el" href="docs_links_and_tools.html#awesome_gb">awesome_gb</a> list.</p>
<h1><a class="anchor" id="autotoc_md47"></a>
Writing optimal C code for the Game Boy and SDCC</h1>
<p>The following guidelines can result in better code for the Game Boy, even though some of the guidance may be contrary to typical advice for general purpose computers that have more resources and speed.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Tools</h2>
<p><a class="anchor" id="const_gbtd_gbmb"></a></p>
<h3><a class="anchor" id="autotoc_md49"></a>
GBTD / GBMB, Arrays and the "const" keyword</h3>
<p><b>Important</b>: The old <a class="el" href="docs_links_and_tools.html#gbtd_gbmb">GBTD/GBMB</a> fails to include the <code>const</code> keyword when exporting to C source files for GBDK. That causes arrays to be created in RAM instead of ROM, which wastes RAM, uses a lot of ROM to initialize the RAM arrays and slows the compiler down a lot.</p>
<p>__Use of <a class="el" href="docs_links_and_tools.html#toxa_gbtd_gbmb">toxa's updated GBTD/GBMB</a> is highly recommended.__</p>
<p>If you wish to use the original tools, you must add the <code>const</code> keyword every time the graphics are re-exported to C source files.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Variables</h2>
<ul>
<li>Use 8-bit values as much as possible. They will be much more efficient and compact than 16 and 32 bit types.</li>
<li>Prefer unsigned variables to signed ones: The code generated will be generally more efficient, especially when comparing two values.</li>
<li>Use explicit types so you always know the size of your variables. <code>int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t</code> and <code>bool</code>. These are standard types defined in <code>stdint.h</code> (<code>#include &lt;stdint.h&gt;</code>) and <code>stdbool.h</code> (<code>#include &lt;stdbool.h&gt;</code>).</li>
<li>Global and local static variables are generally more efficient than local non-static variables (which go on the stack and are slower and can result in slower code).</li>
<li><a class="anchor" id="const_array_data"></a> <code>const</code> keyword: Use const for arrays, structs and variables with read-only (constant) data. It will reduce ROM, RAM and CPU usage significantly. Non-<code>const</code> values are loaded from ROM into RAM inefficiently, and there is no benefit in loading them into the limited available RAM if they aren't going to be changed.</li>
<li>Here is how to delcare <code>const</code> pointers and variables:<ul>
<li>non-const pointer to a const variable: <code>const uint8_t * some_pointer;</code></li>
<li>const pointer to a non-const variable: <code>uint8_t * const some_pointer;</code></li>
<li>const pointer to a const variable: <code>const uint8_t * const some_pointer;</code></li>
<li><a href="https://codeforwin.org/2017/11/constant-pointer-and-pointer-to-constant-in-c.html">https://codeforwin.org/2017/11/constant-pointer-and-pointer-to-constant-in-c.html</a></li>
<li><a href="https://stackoverflow.com/questions/21476869/constant-pointer-vs-pointer-to-constant">https://stackoverflow.com/questions/21476869/constant-pointer-vs-pointer-to-constant</a></li>
</ul>
</li>
<li>For calculated values that don't change, pre-compute results once and store the result. Using lookup-tables and the like can improve speed and reduce code size. Macros can sometimes help. It may be beneficial to do the calculations with an outside tool and then include the result as C code in a const array.</li>
<li>Use an advancing pointer (<code>someStruct-&gt;var = x; someStruct++</code>) to loop through arrays of structs instead of using indexing each time in the loop <code>someStruct[i].var = x</code>.</li>
<li>When modifying variables that are also changed in an Interrupt Service Routine (ISR), wrap them the relevant code block in a <code>__critical { }</code> block. See <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#section.3.9">http://sdcc.sourceforge.net/doc/sdccman.pdf#section.3.9</a></li>
<li>When using constants and literals the <code>U</code>, <code>L</code> and <code>UL</code> postfixes can be used.<ul>
<li><code>U</code> specifies that the constant is unsigned</li>
<li><code>L</code> specifies that the constant is long.</li>
<li>NOTE: In SDCC 3.6.0, the default for char changed from signed to unsigned. The manual says to use <code>--fsigned-char</code> for the old behavior, this option flag is included by default when compiling through <a class="el" href="docs_toolchain.html#lcc">lcc</a>.</li>
</ul>
</li>
</ul>
<p><a class="anchor" id="fixed_point_type"></a></p><ul>
<li>A fixed point type (<code>fixed</code>) is included with GBDK when precision greater than whole numbers is required for 8 bit range values (since floating point is not included in GBDK).</li>
</ul>
<p>See the "Simple Physics" sub-pixel example project.</p>
<p>Code example: </p><pre class="fragment">  fixed player[2];
  ...
  // Modify player position using it's 16 bit representation
  player[0].w += player_speed_x;
  player[1].w += player_speed_y;
  ...
  // Use only the upper 8 bits for setting the sprite position
  move_sprite(0, player[0].h ,player[1].h);
</pre><h2><a class="anchor" id="autotoc_md51"></a>
Code structure</h2>
<ul>
<li>Do not <code>#include</code> <code>.c</code> source files into other <code>.c</code> source files. Instead create <code>.h</code> header files for them and include those. <a href="https://www.tutorialspoint.com/cprogramming/c_header_files.htm">https://www.tutorialspoint.com/cprogramming/c_header_files.htm</a></li>
<li>Instead of using a blocking <a class="el" href="gb_8h.html#a163199ca9660b93aa18c3e4734084121">delay()</a> for things such as sprite animations/etc (which can prevent the rest of the game from continuing) many times it's better to use a counter which performs an action once every N frames. <a class="el" href="sms_8h.html#a78d2fd18666afec116f176d46debb4e7">sys_time</a> may be useful in these cases.</li>
<li>When processing for a given frame is done and it is time to wait before starting the next frame, <a class="el" href="gb_8h.html#adf6ef63efc4bb4950428015c623bca14">wait_vbl_done()</a> can be used. It uses HALT to put the CPU into a low power state until processing resumes. The CPU will wake up and resume processing at the end of the current frame when the Vertical Blanking interrupt is triggered.</li>
<li>Minimize use of multiplication, modulo with non-powers of 2, and division with non-powers of 2. These operations have no corresponding CPU instructions (software functions), and hence are time costly.<ul>
<li>SDCC has some optimizations for:<ul>
<li>Division by powers of 2. For example <code>n /= 4u</code> will be optimized to <code>n &gt;&gt;= 2</code>.</li>
<li>Modulo by powers of 2. For example: <code>(n % 8)</code> will be optimized to <code>(n &amp; 0x7)</code>.</li>
</ul>
</li>
<li>If you need decimal numbers to count or display a score, you can use the GBDK BCD (<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary coded decimal</a>) number functions. See: <a class="el" href="k_2bcd_8h.html">bcd.h</a> and the <code>BCD</code> example project included with GBDK.</li>
</ul>
</li>
<li>Avoid long lists of function parameters. Passing many parameters can add overhead, especially if the function is called often. When applicable globals and local static vars can be used instead.</li>
<li>Use inline functions if the function is short. (with the <code>inline</code> keyword, such as <code>inline uint8_t myFunction() { ... }</code>)</li>
<li>Do not use recursive functions</li>
</ul>
<h2><a class="anchor" id="autotoc_md52"></a>
GBDK API/Library</h2>
<ul>
<li>stdio.h: If you have other ways of printing text, avoid including <a class="el" href="stdio_8h.html">stdio.h</a> and using functions such as <a class="el" href="stdio_8h.html#a79c1db3e4a2aaa60d5afa76f7d984d0b">printf()</a>. Including it will use a large number of the background tiles for font characters. If stdio.h is not included then that space will be available for use with other tiles instead.</li>
<li>drawing.h: The Game Boy graphics hardware is not well suited to frame-buffer style graphics such as the kind provided in <a class="el" href="drawing_8h.html">drawing.h</a>. Due to that, most drawing functions (rectangles, circles, etc) will be slow . When possible it's much faster and more efficient to work with the tiles and tile maps that the Game Boy hardware is built around.</li>
<li><a class="el" href="gb_8h.html#a057979766e52b9f93972dad332a5be5d">waitpad()</a> and <a class="el" href="sms_8h.html#a173b90d3fa8d8dc3f7614924f4cc7179">waitpadup</a> check for input in a loop that doesn't HALT at all, so the CPU will be maxed out until it returns. One alternative is to write a function with a loop that checks input with <a class="el" href="gb_8h.html#ae6e4ae6169648f1bf1fac9785f8f1c71">joypad()</a> and then waits a frame using <a class="el" href="gb_8h.html#adf6ef63efc4bb4950428015c623bca14">wait_vbl_done()</a> (which idles the CPU while waiting) before checking input again.</li>
<li><a class="el" href="gb_8h.html#ae6e4ae6169648f1bf1fac9785f8f1c71">joypad()</a>: When testing for multiple different buttons, it's best to read the joypad state <em>once</em> into a variable and then test using that variable (instead of making multiple calls).</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
Toolchain</h2>
<ul>
<li>See SDCC optimizations: <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#section.8.1">http://sdcc.sourceforge.net/doc/sdccman.pdf#section.8.1</a></li>
<li>Use profiling. Look at the ASM generated by the compiler, write several versions of a function, compare them and choose the faster one.</li>
<li>Use the SDCC <code>--max-allocs-per-node</code> flag with large values, such as <code>50000</code>. <code>--opt-code-speed</code> has a much smaller effect.<ul>
<li>GBDK-2020 (after v4.0.1) compiles the library with <code>--max-allocs-per-node 50000</code>, but it must be turned on for your own code. <br  />
 (example: <code>lcc ... -Wf--max-allocs-per-node50000</code> or <code>sdcc ... --max-allocs-per-node 50000</code>).</li>
<li>The other code/speed flags are <code>--opt-code-speed</code> or <code>--opt-code-size</code>.</li>
</ul>
</li>
<li>Use current SDCC builds from <a href="http://sdcc.sourceforge.net/snap.php">http://sdcc.sourceforge.net/snap.php</a> <br  />
 The minimum required version of SDCC will depend on the GBDK-2020 release. See <a class="el" href="docs_releases.html">GBDK Releases</a></li>
<li>Learn some ASM and inspect the compiler output to understand what the compiler is doing and how your code gets translated. This can help with writing better C code and with debugging.</li>
</ul>
<p><a class="anchor" id="docs_chars_varargs"></a></p>
<h2><a class="anchor" id="autotoc_md54"></a>
chars and vararg functions</h2>
<p>In standard C when <code>chars</code> are passed to a function with variadic arguments (varargs, those delcared with <code>...</code> as a parameter), such as <a class="el" href="stdio_8h.html#a79c1db3e4a2aaa60d5afa76f7d984d0b">printf()</a>, those <code>chars</code> get automatically promoted to <code>ints</code>. For an 8 bit cpu such as the Game Boy's, this is not as efficient or desireable in most cases. So the default SDCC behavior, which GBDK-2020 expects, is that chars will remain chars and <em>not</em> get promoted to ints when <b>explicitly cast as chars while calling a varargs function</b>.</p>
<ul>
<li>They must be explicitly re-cast when passing them to a varargs function, even though they are already declared as chars.</li>
<li>Discussion in SDCC manual: <br  />
 <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#section.1.5">http://sdcc.sourceforge.net/doc/sdccman.pdf#section.1.5</a> <br  />
 <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#subsection.3.5.10">http://sdcc.sourceforge.net/doc/sdccman.pdf#subsection.3.5.10</a></li>
<li>If SDCC is invoked with -std-cxx (&ndash;std-c89, &ndash;std-c99, &ndash;std-c11, etc) then it will conform to standard C behavior and calling functions such as <a class="el" href="stdio_8h.html#a79c1db3e4a2aaa60d5afa76f7d984d0b">printf()</a> with chars may not work as expected.</li>
</ul>
<p>For example: </p><pre class="fragment">unsigned char i = 0x5A;

// NO:
// The char will get promoted to an int, producing incorrect printf output
// The output will be: 5A 00
printf("%hx %hx", i, i);

// YES:
// The char will remain a char and printf output will be as expected
// The output will be: 5A 5A
printf("%hx %hx", (unsigned char)i, (unsigned char)i);
</pre><p>Some functions that accept varargs:</p><ul>
<li><a class="el" href="bgb__emu_8h.html#a90f721e16d0bfe90edc612a07196f702">BGB_printf</a>, <a class="el" href="drawing_8h.html#a5f7a0ed309f9526e9be285146559848c">gprintf()</a>, <a class="el" href="stdio_8h.html#a79c1db3e4a2aaa60d5afa76f7d984d0b">printf()</a>, <a class="el" href="stdio_8h.html#a6c8d9c5b5b6a760b5b2787f0f96b690e">sprintf()</a></li>
</ul>
<p>Also See:</p><ul>
<li>Other cases of char to int promotion: <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#chapter.6">http://sdcc.sourceforge.net/doc/sdccman.pdf#chapter.6</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md55"></a>
When C isn't fast enough</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Update and verify this section for the modernized SDCC and toolchain</dd></dl>
<p>For many applications C is fast enough but in intensive functions are sometimes better written in assembler. This section deals with interfacing your core C program with fast assembly sub routines.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Calling convention</h2>
<p>sdcc in common with almost all C compilers prepends a '_' to any function names. For example the function printf(...) begins at the label _printf::. Note that all functions are declared global.</p>
<p>The parameters to a function are pushed in right to left order with no aligning - so a byte takes up a byte on the stack instead of the more natural word. So for example the function int store_byte( uint16_t addr, uint8_t byte) would push 'byte' onto the stack first then addr using a total of three bytes. As the return address is also pushed, the stack would contain: </p><pre class="fragment">  At SP+0 - the return address

  At SP+2 - addr

  At SP+4 - byte 
</pre><p>Note that the arguments that are pushed first are highest in the stack due to how the Game Boy's stack grows downwards.</p>
<p>The function returns in DE.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Variables and registers</h2>
<p>C normally expects registers to be preserved across a function call. However in the case above as DE is used as the return value and HL is used for anything, only BC needs to be preserved.</p>
<p>Getting at C variables is slightly tricky due to how local variables are allocated on the stack. However you shouldn't be using the local variables of a calling function in any case. Global variables can be accessed by name by adding an underscore.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Segments</h2>
<p>The use of segments for code, data and variables is more noticeable in assembler. GBDK and SDCC define a number of default segments - <code>_CODE</code>, <code>_DATA</code> and <code>_BSS</code>. Two extra segments <code>_HEADER</code> and <code>_HEAP</code> exist for the Game Boy header and malloc heap respectively.</p>
<p>The order these segments are linked together is determined by crt0.s and is currently <code>_CODE</code> in ROM, then <code>_DATA</code>, <code>_BSS</code>, <code>_HEAP</code> in WRAM, with <code>STACK</code> at the top of WRAM. <code>_HEAP</code> is placed after <code>_BSS</code> so that all spare memory is available for the malloc routines. To place code in other than the first two banks, use the segments <code>_CODE_x</code> where x is the 16kB bank number.</p>
<p>As the <code>_BSS</code> segment occurs outside the ROM area you can only use .ds to reserve space in it.</p>
<p>While you don't have to use the <code>_CODE</code> and <code>_DATA</code> distinctions in assembler you may wish to do so consistancy. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
