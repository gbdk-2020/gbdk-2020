<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="cache-control" content="max-age=86400"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GBDK 2020 Docs: Coding Guidelines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GBDK 2020 Docs
   &#160;<span id="projectnumber">4.4.0</span>
   </div>
   <div id="projectbrief">API Documentation for GBDK 2020</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('docs_coding_guidelines.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Coding Guidelines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md68"></a>
Learning C / C fundamentals</h1>
<p>Writing games and other programs with GBDK will be much easier with a basic understanding of the C language. In particular, understanding how to use C on "Embedded Platforms" (small computing systems, such as the Game Boy) can help you write better code (smaller, faster, less error prone) and avoid common pitfalls.</p>
<p><a class="anchor" id="docs_c_tutorials"></a></p>
<h2><a class="anchor" id="autotoc_md69"></a>
General C tutorials</h2>
<ul>
<li><a href="https://www.learn-c.org/">https://www.learn-c.org/</a></li>
<li><a href="https://www.tutorialspoint.com/cprogramming/index.htm">https://www.tutorialspoint.com/cprogramming/index.htm</a></li>
<li><a href="https://www.chiark.greenend.org.uk/~sgtatham/cdescent/">https://www.chiark.greenend.org.uk/~sgtatham/cdescent/</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md70"></a>
Embedded C introductions</h2>
<ul>
<li><a href="http://dsp-book.narod.ru/CPES.pdf">http://dsp-book.narod.ru/CPES.pdf</a></li>
<li><a href="https://www.phaedsys.com/principals/bytecraft/bytecraftdata/bcfirststeps.pdf">https://www.phaedsys.com/principals/bytecraft/bytecraftdata/bcfirststeps.pdf</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md71"></a>
Game Boy games in C</h2>
<ul>
<li><a href="https://gbdev.io/resources.html#c">https://gbdev.io/resources.html#c</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md72"></a>
Understanding the hardware</h1>
<p>In addition to understanding the C language it's important to learn how the Game Boy hardware works. What it is capable of doing, what it isn't able to do, and what resources are available to work with. A good way to do this is by reading the <a class="el" href="docs_links_and_tools.html#Pandocs">Pandocs</a> and checking out the <a class="el" href="docs_links_and_tools.html#awesome_gb">awesome_gb</a> list.</p>
<h1><a class="anchor" id="autotoc_md73"></a>
Writing optimal C code for the Game Boy and SDCC</h1>
<p>The following guidelines can result in better code for the Game Boy, even though some of the guidance may be contrary to typical advice for general purpose computers that have more resources and speed.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
Tools</h2>
<p><a class="anchor" id="const_gbtd_gbmb"></a></p>
<h3><a class="anchor" id="autotoc_md75"></a>
GBTD / GBMB, Arrays and the "const" keyword</h3>
<p><b>Important</b>: The old <a class="el" href="docs_links_and_tools.html#gbtd_gbmb">GBTD/GBMB</a> fails to include the <code>const</code> keyword when exporting to C source files for GBDK. That causes arrays to be created in RAM instead of ROM, which wastes RAM, uses a lot of ROM to initialize the RAM arrays and slows the compiler down a lot.</p>
<p>__Use of <a class="el" href="docs_links_and_tools.html#toxa_gbtd_gbmb">toxa's updated GBTD/GBMB</a> is highly recommended.__</p>
<p>If you wish to use the original tools, you must add the <code>const</code> keyword every time the graphics are re-exported to C source files.</p>
<p><a class="anchor" id="best_practice_dont_read_vram"></a></p>
<h2><a class="anchor" id="autotoc_md76"></a>
Avoid Reading from VRAM</h2>
<p>In general avoid reading from VRAM since that memory is not accessible at all times. If GBDK a API function which reads from VRAM (such as <a class="el" href="gb_8h.html#a55c6581dbe9300dc6df41730f090af51">get_bkg_tile_xy()</a>) is called during a video mode when VRAM is not accessible, then that function call will delay until VRAM becomes accessible again. This can cause unnecessary slowdowns when running programs on the Game Boy. It is also not supported by GBDK on the NES platform.</p>
<p>Instead it is better to store things such as map data in general purpose RAM which does not have video mode access limitations.</p>
<p>For more information about video modes and VRAM access see the pan docs:</p>
<p><a href="https://gbdev.io/pandocs/STAT.html#stat-modes">https://gbdev.io/pandocs/STAT.html#stat-modes</a></p>
<h2><a class="anchor" id="autotoc_md77"></a>
Variables</h2>
<ul>
<li>Use 8-bit values as much as possible. They will be much more efficient and compact than 16 and 32 bit types.</li>
<li>Prefer unsigned variables to signed ones: the code generated will be generally more efficient, especially when comparing two values.</li>
<li>Use explicit types so you always know the size of your variables. <code>int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t</code> and <code>bool</code>. These are standard types defined in <code>stdint.h</code> (<code>#include &lt;stdint.h&gt;</code>) and <code>stdbool.h</code> (<code>#include &lt;stdbool.h&gt;</code>).</li>
<li>Global and local static variables are generally more efficient than local non-static variables (which go on the stack and are slower and can result in slower code).<ul>
<li>An exception to this when there are a small number of local variables (one or two) and the code is not complex. Then the compiler may allocate those variables to CPU registers instead which may be faster.</li>
<li>Functions which use global or static local variables will loose re-entrancy. In most cases it is not a problem, but important to keep in mind.</li>
<li>In particular avoid putting big arrays on the stack, consider static local or global.</li>
</ul>
</li>
<li>Keep the number of arguments passed to functions small (ideally one or two arguments at most). When there are a large number of arguments they get pushed onto the stack and result in more overhead for function calls. See the Calling Conventions in the SDCC compiler manual for details.</li>
<li><a class="anchor" id="const_array_data"></a> <code>const</code> keyword: use const for arrays, structs and variables with read-only (constant) data. It will reduce ROM, RAM and CPU usage significantly. Non-<code>const</code> values are loaded from ROM into RAM inefficiently, and there is no benefit in loading them into the limited available RAM if they aren't going to be changed.</li>
<li>Here is how to declare <code>const</code> pointers and variables:<ul>
<li>non-const pointer to a const variable: <code>const uint8_t * some_pointer;</code></li>
<li>const pointer to a non-const variable: <code>uint8_t * const some_pointer;</code></li>
<li>const pointer to a const variable: <code>const uint8_t * const some_pointer;</code></li>
<li><a href="https://codeforwin.org/2017/11/constant-pointer-and-pointer-to-constant-in-c.html">https://codeforwin.org/2017/11/constant-pointer-and-pointer-to-constant-in-c.html</a></li>
<li><a href="https://stackoverflow.com/questions/21476869/constant-pointer-vs-pointer-to-constant">https://stackoverflow.com/questions/21476869/constant-pointer-vs-pointer-to-constant</a></li>
</ul>
</li>
<li>For calculated values that don't change, pre-compute results once and store the result. Using lookup-tables and similar approaches can improve speed and reduce code size. Macros can sometimes help. It may be beneficial to do the calculations with an outside tool and then include the result as C code in a const array.</li>
<li>Use an advancing pointer (<code>someStruct-&gt;var = x; someStruct++</code>) to loop through arrays of structs instead of using indexing each time in the loop <code>someStruct[i].var = x</code>.</li>
<li>When modifying variables that are also changed in an Interrupt Service Routine (ISR), wrap them the relevant code block in a <code>__critical { }</code> block. See <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#section.3.9">http://sdcc.sourceforge.net/doc/sdccman.pdf#section.3.9</a></li>
<li>When using constants and literals the <code>U</code>, <code>L</code> and <code>UL</code> postfixes can be used.<ul>
<li><code>U</code> specifies that the constant is unsigned</li>
<li><code>L</code> specifies that the constant is long.</li>
<li>NOTE: In SDCC 3.6.0, the default for char changed from signed to unsigned. The manual says to use <code>--fsigned-char</code> for the old behavior, this option flag is included by default when compiling through <a class="el" href="docs_toolchain.html#lcc">lcc</a>.</li>
</ul>
</li>
</ul>
<p><a class="anchor" id="fixed_point_type"></a></p><ul>
<li>A fixed point type (<code>fixed</code>) is included with GBDK when precision greater than whole numbers is required for 8 bit range values (since floating point is not included in GBDK).</li>
</ul>
<p>See the "Simple Physics" sub-pixel example project.</p>
<p>Code example: </p><pre class="fragment">  fixed player[2];
  ...
  // Modify player position using its 16 bit representation
  player[0].w += player_speed_x;
  player[1].w += player_speed_y;
  ...
  // Use only the upper 8 bits for setting the sprite position
  move_sprite(0, player[0].h ,player[1].h);
</pre><h2><a class="anchor" id="autotoc_md78"></a>
Code structure</h2>
<ul>
<li>Do not <code>#include</code> <code>.c</code> source files into other <code>.c</code> source files. Instead create <code>.h</code> header files for them and include those. <a href="https://www.tutorialspoint.com/cprogramming/c_header_files.htm">https://www.tutorialspoint.com/cprogramming/c_header_files.htm</a></li>
<li>Instead of using a blocking <a class="el" href="gb_8h.html#a79b9feff94d525e0237be22dcefd5850">delay()</a> for things such as sprite animations/etc (which can prevent the rest of the game from continuing) many times it's better to use a counter which performs an action once every N frames. <a class="el" href="sms_8h.html#a78d2fd18666afec116f176d46debb4e7">sys_time</a> may be useful in these cases.</li>
<li>When processing for a given frame is done and it is time to wait before starting the next frame, <a class="el" href="gb_8h.html#af57b77452ef377da18e4fbf0288013d1">vsync()</a> can be used. It uses HALT to put the CPU into a low power state until processing resumes. The CPU will wake up and resume processing at the end of the current frame when the Vertical Blanking interrupt is triggered.</li>
<li>Minimize use of multiplication, modulo with non-powers of 2, and division with non-powers of 2. These operations have no corresponding CPU instructions (software functions), and hence are time costly.<ul>
<li>SDCC has some optimizations for:<ul>
<li>Division by powers of 2. For example <code>n /= 4u</code> will be optimized to <code>n &gt;&gt;= 2</code>.</li>
<li>Modulo by powers of 2. For example: <code>(n % 8)</code> will be optimized to <code>(n &amp; 0x7)</code>.</li>
</ul>
</li>
<li>If you need decimal numbers to count or display a score, you can use the GBDK BCD (<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary coded decimal</a>) number functions. See: <a class="el" href="sms_2bcd_8h.html">bcd.h</a> and the <code>BCD</code> example project included with GBDK.</li>
</ul>
</li>
<li>Avoid long lists of function parameters. Passing many parameters can add overhead, especially if the function is called often. Globals and local static vars can be used instead when applicable.</li>
<li>Use inline functions if the function is short (with the <code>inline</code> keyword, such as <code>inline uint8_t myFunction() { ... }</code>).</li>
<li>Do not use recursive functions.</li>
</ul>
<h2><a class="anchor" id="autotoc_md79"></a>
GBDK API/Library</h2>
<ul>
<li>stdio.h: If you have other ways of printing text, avoid including <a class="el" href="stdio_8h.html">stdio.h</a> and using functions such as <a class="el" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf()</a>. Including it will use a large number of the background tiles for font characters. If stdio.h is not included then that space will be available for use with other tiles instead.</li>
<li>drawing.h: The Game Boy graphics hardware is not well suited to frame-buffer style graphics such as the kind provided in <a class="el" href="drawing_8h.html">drawing.h</a>. Due to that, most drawing functions (rectangles, circles, etc) will be slow . When possible it's much faster and more efficient to work with the tiles and tile maps that the Game Boy hardware is built around.</li>
<li><a class="el" href="gb_8h.html#abb680388b5bcbf0c69526d7017ffe8d2">waitpad()</a> and <a class="el" href="sms_8h.html#aebc8751fa428e9845ea25b1060ebe772">waitpadup</a> check for input in a loop that doesn't HALT at all, so the CPU will be maxed out until it returns. One alternative is to write a function with a loop that checks input with <a class="el" href="gb_8h.html#a4344fefd260763e12703138066841b19">joypad()</a> and then waits a frame using <a class="el" href="gb_8h.html#af57b77452ef377da18e4fbf0288013d1">vsync()</a> (which idles the CPU while waiting) before checking input again.</li>
<li><a class="el" href="gb_8h.html#a4344fefd260763e12703138066841b19">joypad()</a>: When testing for multiple different buttons, it's best to read the joypad state <em>once</em> into a variable and then test using that variable (instead of making multiple calls).</li>
</ul>
<h2><a class="anchor" id="autotoc_md80"></a>
Toolchain</h2>
<ul>
<li>See SDCC optimizations: <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#section.8.1">http://sdcc.sourceforge.net/doc/sdccman.pdf#section.8.1</a></li>
<li>For details about default Compiler data types, see the SDCC Manual (follow links and scroll down 1 page)<ul>
<li><a href="https://sdcc.sourceforge.net/doc/sdccman.pdf#section.1.1">https://sdcc.sourceforge.net/doc/sdccman.pdf#section.1.1</a></li>
<li>Note: by default GBDK enables <code>--fsigned-char</code> (via lcc) for SDCC</li>
</ul>
</li>
<li>Use profiling. Look at the ASM generated by the compiler, write several versions of a function, compare them and choose the faster one.</li>
<li>Use the SDCC <code>--max-allocs-per-node</code> flag with large values, such as <code>50000</code>. <code>--opt-code-speed</code> has a much smaller effect.<ul>
<li>GBDK-2020 (after v4.0.1) compiles the library with <code>--max-allocs-per-node 50000</code>, but it must be turned on for your own code. <br  />
 (example: <code>lcc ... -Wf--max-allocs-per-node50000</code> or <code>sdcc ... --max-allocs-per-node 50000</code>).</li>
<li>The other code/speed flags are <code>--opt-code-speed</code> or <code>--opt-code-size</code>.</li>
</ul>
</li>
<li>Use current SDCC builds from <a href="http://sdcc.sourceforge.net/snap.php">http://sdcc.sourceforge.net/snap.php</a> <br  />
 The minimum required version of SDCC will depend on the GBDK-2020 release. See <a class="el" href="docs_releases.html">GBDK Release Notes</a></li>
<li>Learn some ASM and inspect the compiler output to understand what the compiler is doing and how your code gets translated. This can help with writing better C code and with debugging.</li>
</ul>
<p><a class="anchor" id="docs_constant_signedness"></a></p>
<h2><a class="anchor" id="autotoc_md81"></a>
Constants, Signed-ness and Overflows</h2>
<p>There are a some scenarios where the compiler will warn about overflows with constants. They often have to do with mixed signedness between constants and variables. To avoid problems use care about whether or not constants are explicitly defined as unsigned and what type of variables they are used with.</p>
<p><code>WARNING: overflow in implicit constant conversion</code></p>
<ul>
<li>A constant can be used where the the value is too high (or low) for the storage medium causing an value overflow.<ul>
<li>For example this constant value is too high since the max value for a signed 8 bit char is <code>127</code>. <pre class="fragment"> #define TOO_LARGE_CONST 255
 int8_t signed_var = TOO_LARGE_CONST;
</pre></li>
</ul>
</li>
<li>This can also happen when constants are not explicitly declared as unsigned (and so may get treated by the compiler as signed) and then added such that the resulting value exceeds the signed maximum.<ul>
<li>For example, this results in an warning even though the sum total is <code>254</code> which is less than the <code>255</code>, the max value for a unsigned 8 bit char variable. <pre class="fragment">  #define CONST_UNSIGNED 127u
  #define CONST_SIGNED 127
  uint8_t unsigned_var = (CONST_SIGNED + CONST_UNSIGNED);
</pre></li>
<li>It can be avoided by always using the unsigned <code>u</code> when the constant is intended for unsigned operations. <pre class="fragment">  #define CONST_UNSIGNED 127u
  #define CONST_ALSO_UNSIGNED 127u  // &lt;-- Added "u", now no warning
  uint8_t unsigned_var = (CONST_UNSIGNED + CONST_ALSO_UNSIGNED);
</pre></li>
</ul>
</li>
</ul>
<p><a class="anchor" id="docs_chars_varargs"></a></p>
<h2><a class="anchor" id="autotoc_md82"></a>
Chars and vararg functions</h2>
<p>Parameters (chars, ints, etc) to <a class="el" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf</a> / <a class="el" href="stdio_8h.html#a440c82287022737c4f2866786ba8a154">sprintf</a> should always be explicitly cast to avoid type related parameter passing issues.</p>
<p>For example, below will result in the likely unintended output: </p><div class="fragment"><div class="line"><a class="code" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf</a>(str_temp, <span class="stringliteral">&quot;%u, %d, %x\n&quot;</span>, <a class="code" href="stdint_8h.html#a3ea490c9b3617d4479bd80ef93cd5602">UINT16_MAX</a>, <a class="code" href="stdint_8h.html#ad4e9955955b27624963643eac448118a">INT16_MIN</a>, <a class="code" href="stdint_8h.html#a3ea490c9b3617d4479bd80ef93cd5602">UINT16_MAX</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Will output: &quot;65535, 0, 8000&quot;</span></div>
<div class="ttc" id="astdint_8h_html_a3ea490c9b3617d4479bd80ef93cd5602"><div class="ttname"><a href="stdint_8h.html#a3ea490c9b3617d4479bd80ef93cd5602">UINT16_MAX</a></div><div class="ttdeci">#define UINT16_MAX</div><div class="ttdef"><b>Definition:</b> stdint.h:133</div></div>
<div class="ttc" id="astdint_8h_html_ad4e9955955b27624963643eac448118a"><div class="ttname"><a href="stdint_8h.html#ad4e9955955b27624963643eac448118a">INT16_MIN</a></div><div class="ttdeci">#define INT16_MIN</div><div class="ttdef"><b>Definition:</b> stdint.h:117</div></div>
<div class="ttc" id="astdio_8h_html_a133c04c35a1c14c6f8d8078831705661"><div class="ttname"><a href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf</a></div><div class="ttdeci">void printf(const char *format,...)</div></div>
</div><!-- fragment --><p> Instead this will give the intended output: </p><div class="fragment"><div class="line"><a class="code" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf</a>(str_temp, <span class="stringliteral">&quot;%u, %d, %x\n&quot;</span>, (<a class="code" href="stdint_8h.html#adf4d876453337156dde61095e1f20223">uint16_t</a>)<a class="code" href="stdint_8h.html#a3ea490c9b3617d4479bd80ef93cd5602">UINT16_MAX</a>, (<a class="code" href="stdint_8h.html#a66634143db08bebe9b46ab4cb1fc6fd3">int16_t</a>)<a class="code" href="stdint_8h.html#ad4e9955955b27624963643eac448118a">INT16_MIN</a>, (<a class="code" href="stdint_8h.html#adf4d876453337156dde61095e1f20223">uint16_t</a>)<a class="code" href="stdint_8h.html#a3ea490c9b3617d4479bd80ef93cd5602">UINT16_MAX</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Will output: &quot;65535, -32768, FFFF&quot;</span></div>
<div class="ttc" id="astdint_8h_html_a66634143db08bebe9b46ab4cb1fc6fd3"><div class="ttname"><a href="stdint_8h.html#a66634143db08bebe9b46ab4cb1fc6fd3">int16_t</a></div><div class="ttdeci">short int int16_t</div><div class="ttdef"><b>Definition:</b> stdint.h:44</div></div>
<div class="ttc" id="astdint_8h_html_adf4d876453337156dde61095e1f20223"><div class="ttname"><a href="stdint_8h.html#adf4d876453337156dde61095e1f20223">uint16_t</a></div><div class="ttdeci">unsigned short int uint16_t</div><div class="ttdef"><b>Definition:</b> stdint.h:52</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md83"></a>
Chars</h3>
<p>In standard C when <code>chars</code> are passed to a function with variadic arguments (varargs, those declared with <code>...</code> as a parameter), such as <a class="el" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf()</a>, those <code>chars</code> get automatically promoted to <code>ints</code>. For an 8 bit CPU such as the Game Boy's, this is not as efficient or desirable in most cases. So the default SDCC behavior, which GBDK-2020 expects, is that chars will remain chars and <em>not</em> get promoted to ints when <b>explicitly cast as chars while calling a varargs function</b>.</p>
<ul>
<li>They must be explicitly re-cast when passing them to a varargs function, even though they are already declared as chars.</li>
<li>Discussion in SDCC manual: <br  />
 <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#section.1.5">http://sdcc.sourceforge.net/doc/sdccman.pdf#section.1.5</a> <br  />
 <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#subsection.3.5.10">http://sdcc.sourceforge.net/doc/sdccman.pdf#subsection.3.5.10</a></li>
<li>If SDCC is invoked with -std-cxx (&ndash;std-c89, &ndash;std-c99, &ndash;std-c11, etc) then it will conform to standard C behavior and calling functions such as <a class="el" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf()</a> with chars may not work as expected.</li>
</ul>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i = 0x5A;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// NO:</span></div>
<div class="line"><span class="comment">// The char will get promoted to an int, producing incorrect printf output</span></div>
<div class="line"><span class="comment">// The output will be: 5A 00</span></div>
<div class="line"><a class="code" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf</a>(<span class="stringliteral">&quot;%hx %hx&quot;</span>, i, i);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// YES:</span></div>
<div class="line"><span class="comment">// The char will remain a char and printf output will be as expected</span></div>
<div class="line"><span class="comment">// The output will be: 5A 5A</span></div>
<div class="line"><a class="code" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf</a>(<span class="stringliteral">&quot;%hx %hx&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i);</div>
</div><!-- fragment --><p>Some functions that accept varargs:</p><ul>
<li><a class="el" href="gbdk_2emu__debug_8h.html#a910b2802e154473f2e10201f5722bc10">EMU_printf</a>, <a class="el" href="drawing_8h.html#a5f7a0ed309f9526e9be285146559848c">gprintf()</a>, <a class="el" href="stdio_8h.html#a133c04c35a1c14c6f8d8078831705661">printf()</a>, <a class="el" href="stdio_8h.html#a440c82287022737c4f2866786ba8a154">sprintf()</a></li>
</ul>
<p>Also See:</p><ul>
<li>Other cases of char to int promotion: <a href="http://sdcc.sourceforge.net/doc/sdccman.pdf#chapter.6">http://sdcc.sourceforge.net/doc/sdccman.pdf#chapter.6</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md84"></a>
When C isn't fast enough</h1>
<p>For many applications C is fast enough but in intensive functions are sometimes better written in assembly. This section deals with interfacing your core C program with fast assembly sub routines.</p>
<h2><a class="anchor" id="autotoc_md85"></a>
Reusable Local Labels and Inline ASM</h2>
<p>When functions are written assembly it's generally better to not mix the inline ASM with C code and instead write the whole function in assembly.</p>
<p>If they are mixed then descriptive named labels should not be used for inline ASM. This is due to descriptive labels interfering with the expected scope of the reusable local labels generated from the compiled C code. The compiler will not detect this problem and the resulting code may fail to execute correctly without warning.</p>
<p>Instead use reusable local symbols/labels (for example <code>1$:</code>). To learn more about them check the SDAS manual section "1.3.3  Reusable Symbols"</p>
<h2><a class="anchor" id="autotoc_md86"></a>
Variables and registers</h2>
<p>Getting at C variables is slightly tricky due to how local variables are allocated on the stack. However you shouldn't be using the local variables of a calling function in any case. Global variables can be accessed by name by adding an underscore.</p>
<h2><a class="anchor" id="autotoc_md87"></a>
Segments / Areas</h2>
<p>The use of segments/areas for code, data and variables is more noticeable in assembler. GBDK and SDCC define a number of default ones. The order they are linked is determined by crt0.s and is currently as follows for the Game Boy and related clones.</p>
<ul>
<li>ROM (in this order)<ul>
<li><code>_HEADER</code>: For the Game Boy header</li>
<li><code>_CODE</code>: CODE is specified as after BASE, but is placed before it due to how the linker works.</li>
<li><code>_HOME</code></li>
<li><code>_BASE</code></li>
<li><code>_CODE_0</code></li>
<li><code>_INITIALIZER</code>: Constant data used to init RAM data</li>
<li><code>_LIT</code></li>
<li><code>_GSINIT</code>: Code used to init RAM data</li>
<li><code>_GSFINAL</code></li>
</ul>
</li>
<li>Banked ROM<ul>
<li><code>_CODE_x</code> Places code in ROM other than Bank <code>0</code>, where x is the 16kB bank number.</li>
</ul>
</li>
<li>WRAM (in this order)<ul>
<li><code>_DATA</code>: Uninitialized RAM data</li>
<li><code>_BSS</code></li>
<li><code>_INITIALIZED</code>: Initialized RAM data</li>
<li><code>_HEAP</code>: placed after <code>_INITIALIZED</code> so that all spare memory is available for the malloc routines.</li>
<li><code>STACK</code>: at the end of WRAM</li>
</ul>
</li>
</ul>
<p><a class="anchor" id="sdcc_calling_convention"></a></p>
<h2><a class="anchor" id="autotoc_md88"></a>
Calling convention</h2>
<p><em>The following is primarily oriented toward the Game Boy and related clones (sm83 devices), other targets such as sms/gg may vary.</em></p>
<p>SDCC in common with almost all C compilers prepends a <code>_</code> to any function names. For example the function <code>printf(...)</code> begins at the label <code>_printf::.</code> Note that all functions are declared global.</p>
<p>Functions can be marked with <code>OLDCALL</code> which will cause them to use the <code>__sdcccall(0)</code> calling convention (the format used prior to SDCC 4.2 &amp; GBDK-2020 4.1.0).</p>
<p>Starting with SDCC 4.2 and GBDK-2020 4.1.0 the new default calling convention is<code>__sdcccall(1)</code>.</p>
<p>For additional details about the calling convetions, see sections <code>SM83 calling conventions</code> and <code>Z80, Z180 and Z80N calling conventions</code> in the SDCC manual.</p><ul>
<li><a href="http://sdcc.sourceforge.net/doc/sdccman.pdf">http://sdcc.sourceforge.net/doc/sdccman.pdf</a></li>
<li>Section 4.3.9 isn't specific about it, but <code>gbz80</code>/<code>sm83</code> generally share this subheading with <code>z80</code> (Game Boy is partially a sub-port of z80 in SDCC). <a href="https://sdcc.sourceforge.net/doc/sdccman.pdf#subsection.4.3.9">https://sdcc.sourceforge.net/doc/sdccman.pdf#subsection.4.3.9</a></li>
</ul>
<p><a class="anchor" id="banked_calling_convention"></a></p>
<h3><a class="anchor" id="autotoc_md89"></a>
Banked Calling Convention</h3>
<p><em>The following is primarily oriented toward the Game Boy and related clones (sm83 devices), other targets such as sms/gg may vary.</em></p>
<p>Key Points:</p><ul>
<li>Function arguments (if present) are always placed on the stack, right to left without particular alignment</li>
<li>A fixed stack offset (sm83:+4, z80:+3) is added by the <code>Callee</code> (to skip the pushed <code>Caller</code> Bank and additional <code>Trampoline</code> Return Address)</li>
<li>Return values follow the calling convention (<code>__sdcccall(1)</code>, or <code>__sdcccall(0)</code> for <code>OLDCALL</code>)</li>
</ul>
<p>Terminology:</p><ul>
<li><code>Caller</code>: the code which is calling the requested function</li>
<li><code>Callee</code>: the function to be called (declared as <code>BANKED</code> or <code>__banked</code>)</li>
<li><code>Trampoline</code>: The intermediary which performs the bank switching and does hand-off between <code>Caller</code> and <code>Callee</code> during the call and then return.</li>
</ul>
<p>Banked Call Trampoline</p><ul>
<li>Banked calls are performed via a trampoline in the non-banked region 0000-3ffff</li>
<li>The <code>__sdcc_bcall_ehl</code> trampoline is used by default<ul>
<li>With it both calling conventions are supported: <code>__sdcccall(1)</code> (default) or <code>__sdcccall(0)</code> for <code>OLDCALL</code></li>
</ul>
</li>
<li>If <code>--legacy-banking</code> is specified to SDCC the <code>__sdcc_bcall</code> trampoline is used.<ul>
<li>This may only be used with <code>__sdcccall(0)</code></li>
</ul>
</li>
</ul>
<p>Process for a banked call (<code>using __sdcc_bcall_ehl</code>, the default)</p><ol type="1">
<li>The Caller<ul>
<li>Function arguments (if present) are always placed on the stack, right to left without particular alignment</li>
<li>The Bank of Callee function is placed into register E</li>
<li>The Address of Callee function is placed in HL</li>
<li>Calls the bank switch Trampoline (which adds Caller return address to the stack)</li>
</ul>
</li>
<li>The Trampoline<ul>
<li>Saves the Current Bank onto the stack (pushed as AF, so 16 bits)</li>
<li>Switches to the Bank of Callee function (in register E)</li>
<li>Calls the Callee function address in HL (which adds Trampoline return address to the stack)</li>
</ul>
</li>
<li>The Callee Function<ul>
<li>SDCC will use an offset to skip the first N bytes of the stack<ul>
<li>For <code>sm83</code> (GB/AP/DUCK): skip first 4 bytes</li>
<li>For <code>z80</code> (GG/SMS/etc): skip first 3 bytes</li>
</ul>
</li>
<li>Return values follow the calling convention (<code>__sdcccall(1)</code>, or <code>__sdcccall(0)</code> for <code>OLDCALL</code>)</li>
<li>Executes a return to Trampoline</li>
</ul>
</li>
<li>The Trampoline<ul>
<li>Switches to the Bank of the Caller saved on the stack (and moves Stack Pointer past it)</li>
<li>Executes a return to Caller</li>
</ul>
</li>
<li>The Caller<ul>
<li>Cleans up the stack and uses return value (if present) </li>
</ul>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
